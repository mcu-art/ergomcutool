package cli

import (
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/mcu-art/ergomcutool/config"
	"github.com/mcu-art/ergomcutool/iocfile"
	"github.com/mcu-art/ergomcutool/proj"
	"github.com/mcu-art/ergomcutool/tpl"
	"github.com/mcu-art/ergomcutool/utils"
	"github.com/spf13/cobra"
)

var createCmd = &cobra.Command{
	Use:   "create",
	Short: "Create a new project based on .ioc file",
	Run:   CreateProject,
}

func init() {
	rootCmd.AddCommand(createCmd)
	createCmd.PersistentFlags().StringP("path", "p", "", "Path to project root directory")
}

func CreateProject(cmd *cobra.Command, args []string) {
	if len(args) > 0 {
		log.Fatalf("error: too many CLI argument(s): %+v\n", args)
	}

	config.EnsureUserConfigExists()

	path := cmd.Flag("path").Value.String()
	if path != "" {
		if err := os.Chdir(path); err != nil {
			log.Fatalf("error: can't cd into directory %q: %v\n", path, err)
		}
	}

	cwd, _ := os.Getwd()
	log.Printf("Creating a new project...\n")
	config.ParseErgomcutoolConfig(true)

	// Read the .ioc file
	fileNames, err := utils.GetFileList(cwd)
	if err != nil {
		log.Fatalf("error: failed to get file list of the directory %q: %v.\n", cwd, err)
	}
	iocFiles := make([]string, 0, 10)
	for _, file := range fileNames {
		if strings.HasSuffix(file, ".ioc") {
			iocFiles = append(iocFiles, file)
		}
	}
	// iocFile is the selected .ioc file
	var iocFile string
	var ioc *iocfile.Ioc
	parsedIoc := &iocfile.ParsedIoc{}
	parsedIoc.ProjectName = "unnamed_project"
	parsedIoc.DeviceId = "unknown_device"
	if len(iocFiles) == 0 {
		log.Printf(`warning: specified directory doesn't contain a .ioc file
generated by STM32CubeMX. It is recommended that you generate this file first.
`)
		if !utils.GetUserConfirmationViaConsole("Do you wish to continue project creation without it (Y/n)?") {
			log.Printf("The action was canceled by user.")
			os.Exit(0)
		}
	} else {
		iocFile = iocFiles[0]
		if len(iocFiles) > 1 {
			log.Printf(`warning: specified directory contains more than one .ioc file.
File %q will be used to collect the required data.
`, iocFile)
		}
		ioc, err = iocfile.FromFile(iocFile)
		if err != nil {
			log.Fatalf("error: failed to read the .ioc file %q: %v.\n", iocFile, err)
		}
		parsedIoc, err = ioc.Parse()
		if err != nil {
			log.Fatalf("error: failed to parse the .ioc file %q: %v.\n", iocFile, err)
		}
	}

	projectTemplateReplacements := &proj.ErgomcuProjectTemplateReplacements{
		ErgomcutoolVersion: config.Version,
		ProjectName:        parsedIoc.ProjectName,
		DeviceId:           parsedIoc.DeviceId,
	}

	projectTemplateReplacements.OpenocdTarget = findOpenocdTargetFile(
		projectTemplateReplacements.DeviceId)

	if projectTemplateReplacements.OpenocdTarget == "" {
		projectTemplateReplacements.OpenocdTarget = "unknown_openocd_target"
	}

	// Files and templates should be taken from
	// UserConfigDir, that gives the user an ability to customize them
	// if necessary.

	// Return if project file already exists
	projectFileName := "ergomcu_project.yaml"
	projectFilePath := filepath.Join(cwd, projectFileName)
	if exists := utils.FileExists(projectFilePath); exists {
		log.Fatalf("error: project file %q already exists.\nProject creation skipped.\n", projectFilePath)
	}

	// Copy asset files
	src := filepath.Join(config.UserConfigDir, "assets", "files")
	err = utils.CopyDir(src, cwd, config.DefaultDirPermissions, config.DefaultFilePermissions)
	if err != nil {
		log.Fatalf("error: failed to copy project files into %q: %v.\nProject creation failed.\n", cwd, err)
	}

	// Rename .gitignore-default to .gitignore if the latter doesn't exist
	if !utils.FileExists(".gitignore") {
		_ = os.Rename(".gitignore-default", ".gitignore")
	}

	// Rename .clang-format-default to .clang-format if the latter doesn't exist
	if !utils.FileExists(".clang-format") {
		_ = os.Rename(".clang-format-default", ".clang-format")
	}

	// Instantiate templates

	// ergomcu_project.yaml template
	dest := filepath.Join(cwd, "ergomcu_project.yaml")

	err = tpl.InstantiateAssetTemplate("ergomcu_project.yaml.tmpl",
		dest, projectTemplateReplacements, config.DefaultFilePermissions,
	)
	if err != nil {
		log.Fatalf("error: failed to instantiate file %q: %v.\n", dest, err)
	}

	// README.md template
	dest = filepath.Join(cwd, "README.md")
	err = tpl.InstantiateAssetTemplate("README.md.tmpl",
		dest, projectTemplateReplacements, config.DefaultFilePermissions,
	)
	if err != nil {
		log.Printf("warning: failed to instantiate file %q: %v.\n", dest, err)
	}

	// Create '_non_persistent' directory
	nonPersistentDirPath := filepath.Join(cwd, "_non_persistent")
	if !utils.DirExists(nonPersistentDirPath) {
		err := os.Mkdir(nonPersistentDirPath, fs.FileMode(config.DefaultDirPermissions))
		if err != nil {
			log.Printf("warning: failed to create directory %q: %v.\n",
				nonPersistentDirPath, err)
		}
	}
	// Grant execute permissions for "_ergomcutool/scripts/*"
	localScriptDir := filepath.Join("_ergomcutool", "scripts")
	scriptFiles, err := utils.GetFileList(localScriptDir)
	if err != nil {
		log.Printf("warning: failed to list files in directory %q: %v.\n",
			localScriptDir, err)
	}
	for _, file := range scriptFiles {
		filePath := filepath.Join(localScriptDir, file)
		err := os.Chmod(filePath, fs.FileMode(config.DefaultScriptPermissions))
		if err != nil {
			log.Printf("warning: failed to grant 'execute' permissions to %q: %v.\n",
				filePath, err)
		}
	}

	// Patch the .ioc file UserActions
	oldBeforeGenerateAction, err := ioc.ReadValue("ProjectManager.UAScriptBeforePath")
	if err != nil {
		log.Printf("warning: failed to read 'ProjectManager.UAScriptBeforePath' from .ioc file: %v.\n", err)
	}
	if oldBeforeGenerateAction != "" {
		log.Printf("warning: 'ProjectManager.UAScriptBeforePath' value already exists, patch skipped.\n")
	} else {
		_, _ = ioc.ReplaceValue("ProjectManager.UAScriptBeforePath",
			filepath.Join(localScriptDir, "cubemx-before-generate.sh"))
	}

	oldAfterGenerateAction, err := ioc.ReadValue("ProjectManager.UAScriptAfterPath")
	if err != nil {
		log.Printf("warning: failed to read 'ProjectManager.UAScriptAfterPath' from .ioc file: %v.\n", err)
	}
	if oldAfterGenerateAction != "" {
		log.Printf("warning: 'ProjectManager.UAScriptAfterPath' value already exists, patch skipped.\n")
	} else {
		_, _ = ioc.ReplaceValue("ProjectManager.UAScriptAfterPath",
			filepath.Join(localScriptDir, "cubemx-after-generate.sh"))
	}

	// Update the .ioc file
	if iocFile != "" {
		// Remove old backup file and create new
		backupFile := filepath.Join("_non_persistent", "backups", iocFile+".backup")
		_ = os.Remove(backupFile)
		_ = os.Rename(iocFile, backupFile)
		err = os.WriteFile(
			iocFile, ioc.Bytes(), fs.FileMode(config.DefaultFilePermissions))
		if err != nil {
			log.Printf("warning: failed to update file %q: %v.\n", iocFile, err)
		}
	}

	log.Printf("The project was created successfully.")

}

// findOpenocdTargetFile tries to identify openocd target file by matching DeviceId
// with the file names from the openocd scripts/target dir.
func findOpenocdTargetFile(deviceId string) string {
	result := ""
	scriptsTargetDir := filepath.Join(*config.ToolConfig.Openocd.ScriptsPath, "target")
	availableTargets, err := utils.GetFileList(scriptsTargetDir)
	if err != nil {
		log.Printf("warning: failed to get file list of the directory %q: %v.\n", scriptsTargetDir, err)
		return ""
	}

	targetNameLower := strings.ToLower(deviceId)
	var prefixSize uint32 = 4 // start with first 4 letters of the file name
	numberOfMatches := 0
	for {
		matches := make([]string, 0, 50)
		prefix := targetNameLower[:prefixSize]
		for _, targetFile := range availableTargets {
			if strings.HasPrefix(targetFile, prefix) {
				matches = append(matches, targetFile)
			}
		}
		if len(matches) == 0 {
			if result == "" {
				log.Printf(`warning: openocd target couldn't be figured out automatically.
You either haven't properly configured openocd, or the specified device family
%q is not supported. Check the configuration and fix this issue manually
if on-chip debugger functionality is required.
`, deviceId)
			}
			break
		}
		result = matches[0]
		numberOfMatches = len(matches)
		if numberOfMatches == 1 {
			break
		}
		prefixSize++
	}

	if numberOfMatches > 1 {
		log.Printf(`warning: more than one openocd target matches
the specified device family %q.
File %q was chosen as a target, please verify manually if that choice is correct.
`, deviceId, result)
	}
	return result
}
