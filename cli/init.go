package cli

import (
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/mcu-art/ergomcutool/assets"
	"github.com/mcu-art/ergomcutool/config"
	"github.com/mcu-art/ergomcutool/iocfile"
	"github.com/mcu-art/ergomcutool/tpl"
	"github.com/mcu-art/ergomcutool/utils"
	"github.com/spf13/cobra"
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize a new project",
	Run:   OnInitCmd,
}

func init() {
	rootCmd.AddCommand(initCmd)
	initCmd.PersistentFlags().StringP("path", "p", "", "Path to project root directory")
}

func OnInitCmd(cmd *cobra.Command, args []string) {
	if len(args) > 0 {
		log.Fatalf("error: too many CLI argument(s): %+v\n", args)
	}
	path := cmd.Flag("path").Value.String()
	if path != "" {
		if err := os.Chdir(path); err != nil {
			log.Fatalf("error: can't cd into directory %q: %v\n", path, err)
		}
	}
	cwd, _ := os.Getwd()
	log.Printf("Initializing a new project...\n")
	config.ParseErgomcutoolConfig()

	// Read the .ioc file
	fileNames, err := utils.GetDirFileList(cwd)
	if err != nil {
		log.Fatalf("error: failed to get file list of the directory %q: %v.\n", cwd, err)
	}
	iocFiles := make([]string, 0, 10)
	for _, file := range fileNames {
		if strings.HasSuffix(file, ".ioc") {
			iocFiles = append(iocFiles, file)
		}
	}
	iocFileData := &iocfile.IocFileData{}
	iocFileData.ProjectName = "unnamed_project"
	iocFileData.DeviceId = "unknown_device"
	if len(iocFiles) == 0 {
		log.Printf(`warning: specified directory doesn't contain a .ioc file
generated by STM32CubeMX. It is recommended that you generate this file first.
`)
		if !utils.GetUserConfirmationViaConsole("Do you wish to continue initialization (Y/n)?") {
			log.Printf("The action has been canceled by user.")
			os.Exit(0)
		}
	} else {
		iocFile := iocFiles[0]
		if len(iocFiles) > 1 {
			log.Printf(`warning: specified directory contains more than one .ioc file.
File %q will be used to collect the required data.
`, iocFile)
		}
		iocFileData, err = iocfile.ParseIocFile(iocFile)
		if err != nil {
			log.Fatalf("error: failed to read the .ioc file %q: %v.\n", iocFile, err)
		}
	}

	projectTemplateReplacements := &assets.ErgomcuProjectYamlReplacements{
		ErgomcutoolVersion: config.Version,
		ProjectName:        iocFileData.ProjectName,
		DeviceId:           iocFileData.DeviceId,
	}

	projectTemplateReplacements.OpenocdTarget = findOpenocdTargetFile(
		projectTemplateReplacements.DeviceId)

	if projectTemplateReplacements.OpenocdTarget == "" {
		projectTemplateReplacements.OpenocdTarget = "unknown_openocd_target"
	}

	// Files and templates should be taken from
	// UserConfigDir, that gives the user an ability to customize them
	// if necessary.

	// Return if project file already exists
	projectFileName := "ergomcu_project.yaml"
	projectFilePath := filepath.Join(cwd, projectFileName)
	if exists := utils.FileExists(projectFilePath); exists {
		log.Fatalf("error: project file %q already exists.\nInitialization skipped.\n", projectFilePath)
	}

	// Copy asset files
	src := filepath.Join(config.UserConfigDir, "assets", "init_cmd", "files")
	err = utils.CopyDir(src, cwd, config.DefaultDirPermissions, config.DefaultFilePermissions)
	if err != nil {
		log.Fatalf("error: failed to copy project files into %q: %v.\nInitialization failed.\n", cwd, err)
	}

	// Rename .gitignore-default to .gitignore if the latter doesn't exist
	if !utils.FileExists(".gitignore") {
		_ = os.Rename(".gitignore-default", ".gitignore")
	}

	// Rename .clang-format-default to .clang-format if the latter doesn't exist
	if !utils.FileExists(".clang-format") {
		_ = os.Rename(".clang-format-default", ".clang-format")
	}

	// Instantiate templates

	// ergomcu_project.yaml template
	dest := filepath.Join(cwd, "ergomcu_project.yaml")

	//replacements, _ := utils.StructToMap(projectTemplateReplacements)
	err = tpl.InstantiateInitCmdTemplate("ergomcu_project.yaml.tmpl",
		dest, projectTemplateReplacements, config.DefaultFilePermissions,
	)
	if err != nil {
		log.Fatalf("error: failed to instantiate file %q: %v.\n", dest, err)
	}

	// README.md template
	dest = filepath.Join(cwd, "README.md")
	err = tpl.InstantiateInitCmdTemplate("README.md.tmpl",
		dest, projectTemplateReplacements, config.DefaultFilePermissions,
	)
	if err != nil {
		log.Printf("warning: failed to instantiate file %q: %v.\n", dest, err)
	}
	log.Printf("New project was successfully initialized.")

}

// findOpenocdTargetFile tries to identify openocd target file by matching DeviceId
// with the file names from the openocd scripts/target dir.
func findOpenocdTargetFile(deviceId string) string {
	result := ""
	scriptsTargetDir := filepath.Join(*config.ToolConfig.Openocd.ScriptsPath, "target")
	availableTargets, err := utils.GetDirFileList(scriptsTargetDir)
	if err != nil {
		log.Printf("warning: failed to get file list of the directory %q: %v.\n", scriptsTargetDir, err)
		return ""
	}

	targetNameLower := strings.ToLower(deviceId)
	var prefixSize uint32 = 4 // start with first 4 letters of the file name
	numberOfMatches := 0
	for {
		matches := make([]string, 0, 50)
		prefix := targetNameLower[:prefixSize]
		for _, targetFile := range availableTargets {
			if strings.HasPrefix(targetFile, prefix) {
				matches = append(matches, targetFile)
			}
		}
		if len(matches) == 0 {
			if result == "" {
				log.Printf(`warning: openocd target couldn't be figured out automatically.
You either haven't properly configured openocd, or the specified device family
%q is not supported. Check the configuration and fix this issue manually
if on-chip debugger functionality is required.
`, deviceId)
			}
			break
		}
		result = matches[0]
		numberOfMatches = len(matches)
		if numberOfMatches == 1 {
			break
		}
		prefixSize++
	}

	if numberOfMatches > 1 {
		log.Printf(`warning: more than one openocd target matches
the specified device family %q.
File %q was chosen as a target, please verify manually if that choice is correct.
`, deviceId, result)
	}
	return result
}
